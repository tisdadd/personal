import { globSync } from "glob";
import fs from "fs";
import { upperFirst } from "lodash";
import { join } from "path";

const REGISTRATION_PARAMETER_REGEX = /register\(([^)]*)/m;

const FILE_GENERATED_BY_MESSAGE = `/** This file is automatically generated by src/ipc/generateIpcRegistrationScript.ts
*  Manual modifications will be overwritten.
*/`;

function generateForProcessType({
  processType = "",
  prefix = "",
  middle = "",
  postFix = "",
  passToGenerator = "",
  functionIndent = "",
}) {
  let toReturn = prefix;
  let toReturnSecondHalf = middle;

  const files = globSync(`${__dirname}/**/*.${processType}.ts`);
  files.forEach((file, index) => {
    const importPath = file.replace(__dirname, ".").replace(".ts", "");
    const importPathSplit = importPath.split("/");
    const importName = importPathSplit[importPathSplit.length - 1].replace(
      `.${processType}`,
      upperFirst(processType)
    );
    toReturn += `import ${importName} from '${importPath}';`;
    toReturn += "\n";

    // We are utilizing known files
    // eslint-disable-next-line security/detect-non-literal-fs-filename
    const fileContents = fs.readFileSync(file, {
      encoding: "utf-8",
    });

    const [, parameters] = fileContents.match(REGISTRATION_PARAMETER_REGEX);

    let finalPassIn = "";
    if (parameters && parameters.trim().length > 0) {
      finalPassIn = passToGenerator;
    }

    toReturnSecondHalf += `${functionIndent}try {\n`;
    toReturnSecondHalf += `${functionIndent}  ${importName}(${finalPassIn});\n`;
    toReturnSecondHalf += `${functionIndent}} catch (e) {
${functionIndent}  console.warn('registration failed', e.message);
${functionIndent}}`;
    if (index !== files.length - 1) {
      toReturnSecondHalf += "\n";
    }
  });

  const fullString = `${FILE_GENERATED_BY_MESSAGE}
${toReturn}
${toReturnSecondHalf}
${postFix}
`;

  // disable as filename is being fully constructed by us
  // eslint-disable-next-line security/detect-non-literal-fs-filename
  fs.writeFileSync(`${__dirname}/${processType}Script.ts`, fullString);
}

generateForProcessType({
  processType: "preloadRegistration",
  prefix:
    "/* eslint-disable no-console */\nimport { contextBridge } from 'electron';\n",
  middle: "const ipcProcesses = {};\n",
  postFix: "contextBridge.exposeInMainWorld('electronAPI', ipcProcesses);",
  passToGenerator: "ipcProcesses",
});

generateForProcessType({
  processType: "backendRegistration",
  prefix: `// logging warnings if something doesn't work so that they are seen
/* eslint-disable no-console */
import { BrowserWindow } from 'electron';
import BaseBackendRegistrationParameterType from './BaseBackendRegistrationParameter.type';
`,
  middle: `let registrationCalledCount = 0;
const windows: BrowserWindow[] = [];

function backendRegistrationGeneration({ window }: BaseBackendRegistrationParameterType) {
  windows.push(window);
  registrationCalledCount += 1;
  if (registrationCalledCount > 1) {
    return;
  }

`,
  postFix: "}\nexport default backendRegistrationGeneration;",
  passToGenerator: "{ windows }",
  functionIndent: "  ",
});

function generateElectronAPITypeScript() {
  // generate electron API types
  // first get all the preload scripts, front end needs to be aware of these
  const preloadFiles = globSync(`${__dirname}/**/*.preloadRegistration.ts`);

  // now check each, and if a file of the same name but without the
  //  .preloadRegistration.ts exists we will utilize that
  // otherwise assume it is for a callback

  let importStatement = "";
  let parameterExtractStatement = "";
  let electronApiStatement = "";

  preloadFiles.forEach((file) => {
    const checkForPath = file.replace(".preloadRegistration.ts", ".ts");

    const importPath = checkForPath
      .replace(__dirname, "../ipc")
      .replace(".ts", "");
    const importPathSplit = importPath.split("/");
    const importName = importPathSplit[importPathSplit.length - 1];

    // disable as already pulling file name from glob, this is
    // manually modified to check if part of it doesn't exist
    // eslint-disable-next-line security/detect-non-literal-fs-filename
    if (fs.existsSync(checkForPath)) {
      importStatement += `import ${importName} from '${importPath}';`;
      importStatement += "\n";

      parameterExtractStatement += `const [${importName}Event, ...${importName}Rest] = Parameters(typeof ${importName});`;
      parameterExtractStatement += "\n";

      electronApiStatement += `      ${importName}: (...${importName}Rest)=>ReturnType<${importName}>,`;
      electronApiStatement += "\n";
    } else {
      electronApiStatement += `      ${importName}: (callback: (event: Event, data: SetStateAction<any[]>)=>void)=>void,`;
      electronApiStatement += "\n";
    }
  });

  const fullString = `${FILE_GENERATED_BY_MESSAGE}
// needs to match the type being used by the underlying system
/* eslint-disable @typescript-eslint/no-explicit-any */
// linter seeing all of the extracted variables as unused
/* eslint-disable @typescript-eslint/no-unused-vars */
${importStatement}
export {};
${parameterExtractStatement}
declare global {
  interface Window {
    electronAPI: {
${electronApiStatement}
    }
  }
}
`;

  fs.writeFileSync(join(__dirname, "../types/window.d.ts"), fullString);
}

generateElectronAPITypeScript();
